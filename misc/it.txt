#include "inertia_tensor.h"

#include "../error_macros.h"
#include "physic_server.h"

namespace gigno {

    
    float TetrahedronInertiaMoment(size_t axis, glm::vec3 v1, glm::vec3 v2, glm::vec3 v3, glm::vec3 v4) {
        ASSERT_V(axis < 3, 0.0f);

        return  v1[axis] * v1[axis] 
                + v1[axis] * v2[axis]
                + v2[axis] * v2[axis]
                + v1[axis] * v3[axis]
                + v2[axis] * v3[axis]
                + v3[axis] * v3[axis]
                + v1[axis] * v4[axis]
                + v2[axis] * v4[axis]
                + v3[axis] * v4[axis]
                + v4[axis] * v4[axis];
    }

    float TetrahedronInertiaProduct(size_t axis_1, size_t axis_2, glm::vec3 v1, glm::vec3 v2, glm::vec3 v3, glm::vec3 v4) {
        ASSERT_V(axis_1 < 3 && axis_2 < 3, 0.0f);

        return  v1[axis_2] * ( 2*v1[axis_1] + v2[axis_1] + v3[axis_1] + v4[axis_1])
                + v2[axis_2] * (v1[axis_1] + 2*v2[axis_1] + v3[axis_1] + v4[axis_1])
                + v3[axis_2] * (v1[axis_1] + v2[axis_1] + 2*v3[axis_1] + v4[axis_1])
                + v4[axis_2] * (v1[axis_1] + v2[axis_1] + v3[axis_1] + 2*v4[axis_1]);
    }

    /*
    Computes The Inertia Tensor of the object with the local space origin as point of reference.

    Following the formulas presented @https://www.youtube.com/watch?v=GYc99lMdcFE and https://thescipub.com/pdf/jmssp.2005.8.11.pdf
    Credits to blackedout01 and F Tonon (Utha).
    */
    Tensor_t ComputeInertiaTensor(const CollisionModel_t &model) {
        Tensor_t I{0.0f};

        for(size_t i = 0; i < model.Indices.size(); i += 3) {

            const glm::vec3 &v1 = model.Vertices[model.Indices[i]];
            const glm::vec3 &v2 = model.Vertices[model.Indices[i + 1]];
            const glm::vec3 &v3 = model.Vertices[model.Indices[i + 2]];

            const float Determinant = glm::determinant(glm::mat3{v2.x - v1.x, v3.x - v1.x, - v1.x, 
                                                                v2.y - v1.y, v3.y - v1.y, -v1.y,
                                                                v2.z - v1.z, v3.z - v1.z, -v1.z});

            //const float Determinant = glm::dot(v1, glm::cross(v2, v3));

            const float M_100 = Determinant * TetrahedronInertiaMoment(0, v1, v2, v3, glm::vec3{0.0f}) / 60.0f;
            const float M_010 = Determinant * TetrahedronInertiaMoment(1, v1, v2, v3, glm::vec3{0.0f}) / 60.0f;
            const float M_001 = Determinant * TetrahedronInertiaMoment(2, v1, v2, v3, glm::vec3{0.0f}) / 60.0f;

            const float P_100 = Determinant * TetrahedronInertiaProduct(1, 2, v1, v2, v3, glm::vec3{0.0f}) / 120.0f;
            const float P_010 = Determinant * TetrahedronInertiaProduct(0, 2, v1, v2, v3, glm::vec3{0.0f}) / 120.0f;
            const float P_001 = Determinant * TetrahedronInertiaProduct(0, 1, v1, v2, v3, glm::vec3{0.0f}) / 120.0f;

            I += glm::mat3{M_010 + M_001,   -P_001,                 -P_010, 
                            -P_001,           M_100 + M_001,          -P_100, 
                            -P_010,           -P_100,                   M_100 + M_010};
        }

        return I;
    }

}